{
    "contents" : "# Simple constructor ----------------------------------------------------------\n\nrv <- function(x, probs = NULL) {\n  if (is.null(probs)) {\n    probs <- rep(1, length(x)) / length(x)\n  }\n  structure(x, probs = probs, class = \"rv\")\n}\n\n\n# Safer constructor ------------------------------------------------------------\n\nrv <- function(x, probs = NULL) {\n  if (is.null(probs)) {\n    probs <- rep(1, length(x)) / length(x)\n  } else {\n    if (any(probs < 0)) stop(\"Probabilities must be positive\")\n    if (abs(sum(probs) - 1) > 1e-6) stop(\"Probabilities must sum to 1\")\n  }\n  \n  # Simplify by summing probabilities with equal x's. Need to use \n  # addNA since otherwise tapply silently drops groups with missing values\n  grp <- addNA(x, ifany = TRUE)\n  x_new <- as.vector(tapply(x, grp, \"[\", 1))\n  probs <- as.vector(tapply(probs, grp, sum))\n  \n  # Set probs and class attributes\n  structure(x_new, probs = probs, class = \"rv\")\n}\n\n# Some helpers -----------------------------------------------------------------\n\nis.rv <- function(x) inherits(x, \"rv\")\n\nprobs <- function(x) attr(x, \"probs\")\nP <- function(x) {\n  stopifnot(is.logical(x), is.rv(x))\n  sum(probs(x)[x])\n}\n\n\n# Basic methods ----------------------------------------------------------------\n\nprint.rv <- function(x, ...) {\n  X <- format(x, digits = 3)\n  P <- format(probs(x), digits = 3)\n  out <- cbind(X = X, \"P(X)\" = P)\n  rownames(out) <- rep(\"\", nrow(out))\n  print(out, quote = FALSE)\n}\n\nplot.rv <- function(x, ...) {\n  name <- deparse(substitute(x))\n  ylim <- range(0, probs(x))\n  \n  plot(as.numeric(x), probs(x), type = \"h\", ylim = ylim,\n    xlab = name, ylab = paste0(\"P(\", name, \")\"), ...)\n  points(as.numeric(x), probs(x), pch = 20)\n  abline(h = 0, col = \"gray\")  \n}\n\nmean.rv <- function(x, ...) {\n  sum(x * probs(x))\n}\n\n# Methods that use inheritance ------------------------------------------------\n\n`[.rv` <- function(x, i, ...) {\n  rv(NextMethod(), prop.table(probs(x)[i]))\n}\n\nabs.rv <- function(x)                 rv(NextMethod(), probs(x))\nlog.rv <- function(x, base = exp(1))  rv(NextMethod(), probs(x))\nexp.rv <- function(x)                 rv(NextMethod(), probs(x))\nsqrt.rv <- function(x)                rv(NextMethod(), probs(x))\n\n# OR \nArith.rv <- function(x) rv(NextMethod(), probs(x))\n\n# Combine two independent random variables -------------------------------------\n\nas.rv <- function(x) UseMethod(\"as.rv\")\nas.rv.rv <- function(x) x\nas.rv.numeric <- function(x) rv(x)\nas.rv.logical <- function(x) rv(x)\n\n# Combine two independent random variables (including the special case\n# of a random variable and a number). We basically generate the complete \n# two way table, and then collapse down to a random variable\ncombine <- function(e1, e2, fun) {\n  e1 <- as.rv(e1)\n  e2 <- as.rv(e2)\n  \n  # Use outer to generate all pairwise combinations, combining using fun\n  vals <- outer(e1, e2, fun)\n  # Probabilities get multipled together\n  probs <- outer(probs(e1), probs(e2), \"*\")\n  \n  # Rely on rv to collapse any duplicates\n  rv(as.vector(vals), as.vector(probs))\n}\n\n\"+.rv\" <-   function(e1, e2) combine(e1, e2, `+`)\n\"-.rv\" <-   function(e1, e2) combine(e1, e2, `-`)\n\"/.rv\" <-   function(e1, e2) combine(e1, e2, `/`)\n\n# OR\nOps.rv <- function(x) rv(NextMethod(), probs(x), .Generic)\n",
    "created" : 1421527952631.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "159408563",
    "id" : "A5C37CC2",
    "lastKnownWriteTime" : 1421360291,
    "path" : "~/Dropbox/15-masterclass/day-1/rv.R",
    "project_path" : "rv.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}
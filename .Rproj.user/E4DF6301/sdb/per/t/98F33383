{
    "contents" : "# Creation and testing -------------------------------------------------------\n\nminmax <- function(x, minx = min(x), maxx = max(x)) {\n  stopifnot(is.numeric(x))\n  \n  structure(x, min = minx, max = maxx, class = \"minmax\")\n}\nminmax(1:10)\n\nis.minmax <- function(x) {\n  inherits(x, \"minmax\")\n}\nis.minmax(minmax(1:10))\n\n# Checking validity ----------------------------------------------------------\n\nminmax(1:10, max = 5)\n\n# Your turn: how could we re-write minmax to prevent this from happening?\nminmax <- function(x, minx = min(x), maxx = max(x)) {\n  stopifnot(is.numeric(x))\n  stopifnot(all(minx <= x))\n  stopifnot(all(maxx >= x))\n  \n  structure(x, min = minx, max = maxx, class = \"minmax\")\n}\n# minmax(1:10, max = 5)\n\n# Object display -------------------------------------------------------------\n\n# First method is usually a print method, so you can more easily\n# see what's going on.  Always look at the generic first so that you\n# can match the arguments correctly.\nprint\nprint.minmax <- function(x, ...) {\n  print.default(as.numeric(x))\n  cat(\"Range: [\", attr(x, \"min\"), \", \", attr(x, \"max\"), \"]\\n\", sep = \"\")  \n}\n\nminmax(1:10)\n\n# Infix operators ------------------------------------------------------------\n\na <- minmax(1:10)\nb <- minmax(1:5, max = 20)\na + b\n\n`+`\n`+.minmax` <- function(e1, e2) {\n  minmax(NextMethod(), min = min(e1) + min(e2), max = max(e1) + max(e2))\n}\n\na + b\na + 3\n3 + a\n\n# Read the `Ops` section in ?S3groupGeneric to see why this works\n\n`-.minmax` <- function(e1, e2) {\n  minmax(NextMethod(), \n    min = min(e1) - max(e2), \n    max = max(e1) - min(e2)\n  )\n}\n\n# More methods ---------------------------------------------------------------\n\na <- minmax(1:10, max = 20) \n\nmax(a)\nmin(a)\nrange(a)\nmax\n# How do you know if a function is generic?\n#  * includes UseMethod (like print)\n#  * is a primitive or internal and listed in:\n#    * ?S3groupGeneric\n#    * ?InternalMethods\nmax.minmax <- function(..., na.rm = FALSE) {\n  parts <- list(...)\n  if (length(parts) == 1) {\n    attr(parts[[1]], \"max\")\n  } else {\n    stop(\"Maximum of more than one minmax not implemented\")    \n  }\n}\n\n# Your turn: Extend to min.  Extend to so that it works when you provide\n# multiple minmaxes.  Does range work as you expect?\nmax.minmax <- function(..., na.rm = FALSE) {\n  parts <- list(...)\n  if (length(parts) == 1) {\n    attr(parts[[1]], \"max\")\n  } else {\n    max(vapply(parts, max, numeric(1)))\n  }\n}\nmin.minmax <- function(..., na.rm = FALSE) {\n  parts <- list(...)\n  if (length(parts) == 1) {\n    attr(parts[[1]], \"min\")\n  } else {\n    min(vapply(parts, min, numeric(1)))\n  }\n}\nrange.minmax <- function(..., na.rm = FALSE) {\n  c(min(..., na.rm = TRUE), max(..., na.rm = TRUE))\n}\n\na <- minmax(1:10, max = 20) \na[1:5]\n\n# Always need to locate the generic so you can figure out\n# what the arguments are.  This is sometimes hard!\n\"[.minmax\" <- function(x, ...) {\n  minmax(NextMethod(), minx = attr(x, \"min\"), maxx = attr(x, \"max\"))\n}\na[1:5]\na <- minmax(1:10)\na[1:5]\nmin(a[1:5])\nmax(a[1:5])\n\nrange(a[1:5])\nrange(a[1:5])\n\n# How can we store in a data frame?\n\n# df <- data.frame(a = a)\n\nas.data.frame.minmax <- function(x, ...) {\n  structure(list(x), row.names = seq_along(x), class = \"data.frame\")\n}\ndf <- data.frame(a = a)\ndf[1:5, \"a\"]\n\n\n",
    "created" : 1421527918615.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "783152492",
    "id" : "98F33383",
    "lastKnownWriteTime" : 1410206802,
    "path" : "~/Dropbox/15-masterclass/day-1/minmax.R",
    "project_path" : "minmax.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}